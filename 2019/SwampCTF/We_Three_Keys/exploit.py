from pwn import *
import re

def split_in_blocks(ct):
    return re.findall(".{32}", ct)

def hexXor(a, b):
    """
    Produces an XOR result of two equal length Hex values
    """

    if len(a) != len(b):
        raise("Error: incorrect length in hexXor")

    length = len(a)

    binA = bin(int(a, 16))[2:].zfill(length)
    binB = bin(int(b, 16))[2:].zfill(length)

    xor = int(binA, 2) ^ int(binB, 2)

    # Format ensures that the hex values are always the same length
    hexOutput = format(xor, f"#0{length + 2}x")[2:]

    return hexOutput

def get_key(keyNumber, payload):
    r.recvuntil("<= ")
    r.sendline(f"{keyNumber}")
    r.recvuntil("<= ")
    r.sendline("1")
    r.recvuntil("<= ")
    r.sendline(payload)

    ct = r.read().decode("utf-8")

    # Hacked cipher text
    ct_blocks = split_in_blocks(ct)
    ct_blocks[1] = "00" * 16
    ct_blocks[2] = ct_blocks[0]

    r.recvuntil("<= ")
    r.sendline("2")
    r.recvuntil("<= ")
    r.sendline("".join(ct_blocks))

    ct_prime = r.read().decode("utf-8")
    ct_prime_blocks = split_in_blocks(ct_prime)

    key = hexXor(ct_prime_blocks[0], ct_prime_blocks[2])
    
    r.recvuntil("<= ")
    r.sendline("3")

    return key

r = remote("chal1.swampctf.com", 1441)

# Creation of the faked CT
pt = "41" * 16
payload = pt + pt + pt

flag = ""
flag += get_key(1, payload)
flag += get_key(2, payload)
flag += get_key(3, payload)

print(flag)
